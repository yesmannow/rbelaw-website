/**
 * Download + optimize newsroom/blog images referenced by scraped blog posts.
 *
 * - Downloads unique image URLs from `scraped-content/blog-posts.json`
 * - Optimizes to WebP + AVIF using sharp
 * - Writes to `public/images/newsroom/`
 * - Generates `src/lib/data/blog-images.ts` mapping slug -> local webp path
 */

import fs from 'node:fs/promises'
import path from 'node:path'
import crypto from 'node:crypto'
import sharp from 'sharp'
import axios from 'axios'

type ScrapedBlogPost = {
  slug: string
  image?: string
}

function safeBasenameFromUrl(url: string) {
  const base = url.split('?')[0].split('#')[0]
  const name = base.substring(base.lastIndexOf('/') + 1) || 'image'
  return name.replace(/[^a-zA-Z0-9._-]/g, '_')
}

function hash10(input: string) {
  return crypto.createHash('sha1').update(input).digest('hex').slice(0, 10)
}

async function fetchBuffer(url: string): Promise<Buffer> {
  const res = await axios.get<ArrayBuffer>(url, {
    responseType: 'arraybuffer',
    timeout: 30000,
    maxRedirects: 5,
    validateStatus: (status) => status >= 200 && status < 400,
  })
  return Buffer.from(res.data)
}

async function fetchWithRetry(url: string, attempts: number = 3): Promise<Buffer> {
  let lastErr: unknown
  for (let i = 0; i < attempts; i++) {
    try {
      // eslint-disable-next-line no-await-in-loop
      return await fetchBuffer(url)
    } catch (err) {
      lastErr = err
      // eslint-disable-next-line no-await-in-loop
      await new Promise(r => setTimeout(r, 600 * (i + 1)))
    }
  }
  throw lastErr instanceof Error ? lastErr : new Error(`Failed to fetch ${url}`)
}

async function withConcurrency<T>(
  items: T[],
  limit: number,
  worker: (item: T, idx: number) => Promise<void>
) {
  let i = 0
  const runners = new Array(Math.min(limit, items.length)).fill(0).map(async () => {
    while (i < items.length) {
      const idx = i++
      // eslint-disable-next-line no-await-in-loop
      await worker(items[idx], idx)
    }
  })
  await Promise.all(runners)
}

async function main() {
  const root = process.cwd()
  const inputPath = path.join(root, 'scraped-content', 'blog-posts.json')
  const outDir = path.join(root, 'public', 'images', 'newsroom')
  const mappingPath = path.join(root, 'src', 'lib', 'data', 'blog-images.ts')

  await fs.mkdir(outDir, { recursive: true })

  const raw = await fs.readFile(inputPath, 'utf8')
  const data = JSON.parse(raw) as ScrapedBlogPost[]

  const slugToUrl = new Map<string, string>()
  for (const post of data) {
    if (post?.slug && post?.image && typeof post.image === 'string') {
      slugToUrl.set(post.slug, post.image)
    }
  }

  const uniqueUrls = Array.from(new Set(slugToUrl.values()))

  // url -> local webp path (public-relative)
  const urlToLocalWebp = new Map<string, string>()

  // eslint-disable-next-line no-console
  console.log(`Downloading ${uniqueUrls.length} unique images...`)

  let failures = 0

  await withConcurrency(uniqueUrls, 4, async (url) => {
    const base = safeBasenameFromUrl(url)
    const stem = `${hash10(url)}-${base}`.replace(/\.(png|jpe?g|webp|avif)$/i, '')

    const webpName = `${stem}.webp`
    const avifName = `${stem}.avif`
    const webpPath = path.join(outDir, webpName)
    const avifPath = path.join(outDir, avifName)

    // Skip if already generated
    try {
      await fs.access(webpPath)
      urlToLocalWebp.set(url, `/images/newsroom/${webpName}`)
      return
    } catch {
      // continue
    }

    let buf: Buffer
    try {
      buf = await fetchWithRetry(url, 3)
    } catch (err) {
      failures++
      // eslint-disable-next-line no-console
      console.warn(`⚠️  Skipping image (fetch failed): ${url}`)
      return
    }

    const img = sharp(buf, { failOn: 'none' }).rotate()

    // Generate AVIF (high compression) + WebP (great compatibility)
    await Promise.all([
      img.clone().avif({ quality: 55 }).toFile(avifPath).catch(() => undefined),
      img.clone().webp({ quality: 75 }).toFile(webpPath),
    ])

    urlToLocalWebp.set(url, `/images/newsroom/${webpName}`)
  })

  // Build slug -> local webp path mapping
  const slugToLocal: Record<string, string> = {}
  for (const [slug, url] of slugToUrl.entries()) {
    const local = urlToLocalWebp.get(url)
    if (local) slugToLocal[slug] = local
  }

  const out = `/**
 * Blog image mapping (slug -> local image path).
 *
 * Auto-generated by \`scripts/download-blog-images.ts\`.
 * Do not edit by hand.
 */

export const blogImageBySlug: Record<string, string> = ${JSON.stringify(slugToLocal, null, 2)} as const
`

  await fs.writeFile(mappingPath, out, 'utf8')
  // eslint-disable-next-line no-console
  console.log(`✓ Wrote ${mappingPath} (${Object.keys(slugToLocal).length} slugs, ${failures} image failures)`)
}

main().catch(err => {
  // eslint-disable-next-line no-console
  console.error(err)
  process.exit(1)
})


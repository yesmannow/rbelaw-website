/**
 * Generate a slim taxonomy map (slug -> categories/tags) from scraped blog JSON.
 *
 * Why: the current `src/lib/data/blog-posts.ts` content blocks are great, but
 * categories/tags are empty. The scraped JSON has them, so we merge at runtime
 * without regenerating the huge TS data file.
 */

import fs from 'node:fs/promises'
import path from 'node:path'

type ScrapedBlogPost = {
  slug: string
  categories?: unknown
  tags?: unknown
}

function toStringArray(value: unknown): string[] {
  if (!Array.isArray(value)) return []
  return value
    .map(v => (typeof v === 'string' ? v.trim() : ''))
    .filter(Boolean)
}

async function main() {
  const root = process.cwd()
  const inputPath = path.join(root, 'scraped-content', 'blog-posts.json')
  const outputPath = path.join(root, 'src', 'lib', 'data', 'blog-taxonomy.ts')

  const raw = await fs.readFile(inputPath, 'utf8')
  const data = JSON.parse(raw) as ScrapedBlogPost[]

  const entries = data
    .filter(p => typeof p?.slug === 'string' && p.slug.length > 0)
    .map(p => {
      const slug = p.slug
      const categories = toStringArray(p.categories)
      const tags = toStringArray(p.tags)
      return [slug, { categories, tags }] as const
    })
    .sort((a, b) => a[0].localeCompare(b[0]))

  const out = `/**
 * Blog taxonomy mapping (slug -> categories/tags).
 *
 * Auto-generated by \`scripts/generate-blog-taxonomy.ts\`.
 * Do not edit by hand.
 */

export const blogTaxonomyBySlug: Record<string, { categories: string[]; tags: string[] }> = ${JSON.stringify(
    Object.fromEntries(entries),
    null,
    2
  )} as const
`

  await fs.writeFile(outputPath, out, 'utf8')
  // eslint-disable-next-line no-console
  console.log(`âœ“ Wrote ${outputPath} (${entries.length} slugs)`)
}

main().catch(err => {
  // eslint-disable-next-line no-console
  console.error(err)
  process.exit(1)
})

